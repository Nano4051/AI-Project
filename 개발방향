가능합니다 — 충분히 실현 가능한 프로젝트입니다. 🎯
요약하면 (1) 차량 감지 → (2) 트래킹 → (3) 주차구역 매핑(사전 정의 또는 자동 추출) → (4) 점유 판정 → (5) 빈 슬롯 좌표 반환 순서로 처리하면 됩니다.
아래에 실제 구현 로드맵, 핵심 아이디어, 필요한 도구, 그리고 바로 써볼 수 있는 파이썬 샘플 코드(감지+트래킹+슬롯 판정) 을 단계별로 정리해 드릴게요.

1) 전체 접근 방식(파이프라인)

비디오 프레임 추출 — OpenCV로 프레임 단위 처리

차량 검출(Detection) — YOLOv8 / YOLOv5, Faster-RCNN 등 (Ultralytics 권장)

객체 추적(Tracking) — DeepSORT / BYTETrack 등으로 ID 유지

주차 슬롯 정의(또는 자동 추출)

사전 정의 방식: 관리자(혹은 초기 설정)에서 각각의 슬롯을 이미지 좌표(폴리곤)로 정의

자동 추출 방식: 빈장소 패턴 분석/클러스터링/직선 검출 등(더 어려움)

점유 판정(Occupancy)

각 프레임에서 검출된 차량 바운딩박스와 슬롯 폴리곤의 IoU 또는 overlap 비율로 판정

일정 프레임 연속으로 비어있으면 빈 슬롯으로 확정(노이즈 제거)

좌표 반환

화면 좌표(픽셀) 또는 균일한 bird-eye (원근 보정) 좌표계로 반환

저장/조회

MySQL에 로그 및 슬롯 상태 저장 → React에서 실시간 조회

2) 사용 기술 스택 제안

AI / 서버(감지·트래킹): Python, OpenCV, ultralytics (YOLOv8), deep_sort_realtime 또는 ByteTrack

환경 관리: Miniconda (environment.yml)

DB: MySQL (슬롯 정의, 로그, 통계 저장)

API: FastAPI (AI 서비스 제공)

프론트엔드: React (대시보드 + 지도 / 이미지 위에 슬롯 폴리곤 표시)

옵션: Docker / docker-compose로 통합 배포

3) 핵심 설계/의사결정 포인트

슬롯 정의 방식: 초기에는 사람이 수동으로 슬롯 폴리곤을 그려 DB에 저장하는 방식 추천(정확·간단).

좌표계: UI에서 보여줄 때는 원본 이미지 좌표로 표시해도 되지만, 실제 거리/면적을 원하면 카메라 캘리브레이션 + 호모그래피로 bird-eye 변환 권장.

신뢰도(안정성): 짧은 깜빡임을 필터링하려면 N 프레임 연속 빈 상태 또는 스무딩(rolling window) 적용.

야간/역광: 조도 변화에 취약 → IR 카메라, 조명, 또는 low-light 모델 필요.

4) 간단한 구현 예제 (YOLOv8 + DeepSORT + 슬롯 충돌 검사)

아래 코드는 개념 증명(PoC)용으로 ultralytics YOLOv8, deep_sort_realtime를 사용한 예입니다.

전제: pip install ultralytics opencv-python deep_sort_realtime shapely fastapi uvicorn 등이 설치되어 있어야 합니다.

# ai_service/detect_and_map.py
from ultralytics import YOLO
import cv2
from deep_sort_realtime.deepsort_tracker import DeepSort
from shapely.geometry import Polygon, box
import time
import json

# 1) 모델 로드
model = YOLO("yolov8n.pt")  # 또는 yolov8s.pt 등

# 2) 트래커 초기화
tracker = DeepSort(max_age=30)

# 3) 예시: 수동으로 정의한 슬롯 (각 슬롯은 폴리곤 리스트 of (x,y))
# 실제로는 DB에서 불러오세요.
parking_slots = {
    "S1": [(100,200),(220,200),(220,320),(100,320)],
    "S2": [(230,200),(350,200),(350,320),(230,320)],
    # ...
}

slot_polygons = {k: Polygon(v) for k,v in parking_slots.items()}

def bbox_to_shapely(x1,y1,x2,y2):
    return box(x1,y1,x2,y2)

def process_video(video_path, output_callback=None):
    cap = cv2.VideoCapture(video_path)
    fps = cap.get(cv2.CAP_PROP_FPS) or 20
    frame_idx = 0
    # slot status: store last seen occupied frames
    slot_status = {k: {"occupied": False, "last_seen": -999} for k in parking_slots}

    while True:
        ret, frame = cap.read()
        if not ret:
            break
        frame_idx += 1
        results = model(frame, imgsz=640)[0]  # ultralytics returns results
        detections = []
        for r in results.boxes:
            cls = int(r.cls[0])
            conf = float(r.conf[0])
            # COCO class vehicle: car=2, truck=7, bus=5, motorcycle=3 (확인 필요)
            if cls in [2,3,5,7]:  # 차량 계열만
                x1,y1,x2,y2 = map(int, r.xyxy[0])
                detections.append(([x1,y1,x2-x1,y2-y1], conf, "vehicle"))

        # DeepSORT expects list of detections as (xywh), confidence, class
        tracks = tracker.update_tracks(detections, frame=frame)

        # Build shapely boxes for vehicles
        vehicle_boxes = []
        for t in tracks:
            if not t.is_confirmed():
                continue
            track_id = t.track_id
            l,t_,w,h = t.to_ltwh()
            x1,y1,x2,y2 = int(l), int(t_), int(l+w), int(t_+h)
            vehicle_boxes.append((track_id, bbox_to_shapely(x1,y1,x2,y2), (x1,y1,x2,y2)))

        # For each slot, check overlap with any vehicle
        now = time.time()
        for slot_id, poly in slot_polygons.items():
            occupied = False
            for tid, vpoly, bbox in vehicle_boxes:
                inter_area = poly.intersection(vpoly).area
                if inter_area / vpoly.area > 0.3 or inter_area / poly.area > 0.3:
                    occupied = True
                    slot_status[slot_id]["last_seen"] = frame_idx
                    slot_status[slot_id]["occupied"] = True
                    break
            if not occupied:
                # If not detected for N frames, mark empty
                if frame_idx - slot_status[slot_id]["last_seen"] > (fps * 2):  # 2초 관성
                    slot_status[slot_id]["occupied"] = False

        # Prepare response: list of empty slots + their centroids (pixel coords)
        empty_slots = []
        for sid, info in slot_status.items():
            if not info["occupied"]:
                centroid = slot_polygons[sid].centroid
                empty_slots.append({"slot": sid, "cx": centroid.x, "cy": centroid.y})

        # callback or yield result
        if output_callback:
            output_callback(frame_idx, empty_slots, slot_status)

    cap.release()

# 샘플 콜백: 프레임별 빈 슬롯 프린트
def cb(frame_idx, empty_slots, slot_status):
    print(f"frame {frame_idx}: empty {len(empty_slots)} slots -> {empty_slots}")

if __name__ == "__main__":
    process_video("watermarked_preview.mp4", output_callback=cb)


이 코드는 핵심 아이디어(검출 → 트래킹 → 슬롯-차량 겹침 비율로 점유 판정)를 보여줍니다.
실제 환경에서는 threshold 조정, 노이즈 필터, 더 강한 모델(YOLOv8s/YOLOv8x), 하드웨어 가속(GPU) 등을 적용하세요.

5) 좌표 표기(프론트 전달 방식)

React로 전달할 때는 JSON:

{
  "timestamp": "2025-11-11T09:30:00",
  "empty_slots": [
    {"slot":"S1","centroid":[150,250],"polygon":[[100,200],[220,200],[220,320],[100,320]]},
    ...
  ],
  "occupied_slots": [...]
}


프론트에서 이미지 위에 SVG 폴리곤으로 오버레이하거나, bird-eye 변환을 적용해서 실제 주차장 맵 위에 정확한 위치 표시 가능.

6) MySQL 테이블 예시
CREATE TABLE parking_slots (
  slot_id VARCHAR(32) PRIMARY KEY,
  polygon TEXT, -- JSON 문자열로 (list of [x,y])
  label VARCHAR(64)
);

CREATE TABLE slot_logs (
  id INT AUTO_INCREMENT PRIMARY KEY,
  slot_id VARCHAR(32),
  timestamp DATETIME,
  status ENUM('OCCUPIED','EMPTY'),
  image_path VARCHAR(255)
);

7) 실전 팁 / 고려사항

슬롯 폴리곤을 정확히 정의하세요. 초기에는 수동 라벨링(React에서 폴리곤 그리기 UI)을 권장합니다.

카메라 각도/해상도 변화에 민감 → 재보정 절차 필요.

차량 종류(이륜/사륜) 구분이 필요하면 클래스별로 분류.

성능: 실시간 처리 목표면 GPU 필요. 추론 최적화(배치, FP16)를 고려하세요.

오탐/미탐 보정: 역광·그림자·주차선 색상 등으로 오탐 발생 가능 → 후처리 룰을 넣어 안정화.

프라이버시/법적: 번호판 등 개인정보를 저장/노출 시 관련 법규(개인정보보호법 등) 준수 필요.

8) 다음으로 바로 도와드릴 수 있는 것

원하시면 아래 중 하나를 즉시 만들어 드립니다:

A. FastAPI + 감지 엔드포인트(POST /analyze에 비디오/프레임 전송 → JSON 반환) 코드 뼈대

B. React에서 이미지 위에 슬롯 폴리곤을 그려 DB로 저장하는 UI 코드(컴포넌트)

C. 위 PoC 코드를 확장해 동영상 업로드 → 처리 → MySQL 저장 전체 파이프라인 예시(도커 포함)

D. 제공하신 mp4(링크)로 간단한 테스트 스크립트 실행하는 방법(로컬에서 다운로드하고 돌리는 절차 + 필요한 명령어)

원하시는 항목(A/B/C/D) 번호 알려주시면, 바로 코드/설정 파일과 함께 만들어 드리겠습니다. 🚀
